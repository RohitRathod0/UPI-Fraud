"""
Malware/Device Compromise Detection Model
XGBoost classifier for detecting compromised devices
"""

import pandas as pd
import numpy as np
from xgboost import XGBClassifier
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import classification_report, roc_auc_score, confusion_matrix
import joblib
import json

class MalwareDetector:
    def __init__(self):
        self.model = XGBClassifier(
            n_estimators=180,
            max_depth=7,
            learning_rate=0.06,
            subsample=0.85,
            colsample_bytree=0.85,
            min_child_weight=3,
            gamma=0.15,
            scale_pos_weight=3,
            random_state=42,
            eval_metric='auc'
        )
        
        self.feature_cols = [
            'app_modified',
            'root_jailbreak',
            'suspicious_permissions',
            'app_from_unknown_source',
            'has_overlay_attack',
            'clipboard_hijack',
            'device_security_score',
            'permission_risk',
            'malware_risk_composite',
            'amount',
            'time_risk',
            'transaction_count_24h'
        ]
        
        self.feature_importance = None
    
    def prepare_data(self, df):
        """Prepare malware detection features"""
        malware_mask = (
            (df['app_modified'] == 1) |
            (df['root_jailbreak'] == 1) |
            (df['suspicious_permissions'] > 3) |
            (df['has_overlay_attack'] == 1)
        )
        
        fraud_mask = df['is_fraud'] == 1
        random_sample = np.random.rand(len(df)) < 0.25
        
        final_mask = fraud_mask | (malware_mask & random_sample) | (random_sample & ~fraud_mask)
        
        X = df[final_mask][self.feature_cols].copy()
        y = df[final_mask]['is_fraud'].copy()
        
        return X, y
    
    def train(self, df):
        """Train malware detection model"""
        print("\n=== Training Malware Detector ===")
        
        X, y = self.prepare_data(df)
        print(f"Training samples: {len(X)}, Fraud rate: {y.mean()*100:.2f}%")
        
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )
        
        # Train model
        self.model.fit(X_train, y_train)
        
        # Evaluate
        y_pred = self.model.predict(X_test)
        y_pred_proba = self.model.predict_proba(X_test)[:, 1]
        
        print("\n=== Malware Detector Performance ===")
        print(classification_report(y_test, y_pred, target_names=['Legitimate', 'Malware']))
        print(f"ROC-AUC Score: {roc_auc_score(y_test, y_pred_proba):.4f}")
        
        # Feature importance
        self.feature_importance = dict(zip(self.feature_cols, self.model.feature_importances_))
        print("\n=== Top 5 Important Features ===")
        for feat, imp in sorted(self.feature_importance.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"{feat}: {imp:.4f}")
        
        # Cross-validation
        cv_scores = cross_val_score(self.model, X_train, y_train, cv=5, scoring='roc_auc')
        print(f"\nCross-validation AUC: {cv_scores.mean():.4f} (+/- {cv_scores.std()*2:.4f})")
        
        # Confusion matrix
        cm = confusion_matrix(y_test, y_pred)
        print("\n=== Confusion Matrix ===")
        print(f"True Negatives:  {cm[0, 0]}")
        print(f"False Positives: {cm[0, 1]}")
        print(f"False Negatives: {cm[1, 0]}")
        print(f"True Positives:  {cm[1, 1]}")
        
        fn_rate = cm[1, 0] / (cm[1, 0] + cm[1, 1]) if (cm[1, 0] + cm[1, 1]) > 0 else 0
        print(f"\nFalse Negative Rate: {fn_rate*100:.2f}% (Target: <2%)")
        
        return self.model
    
    def predict(self, features_dict):
        """Predict malware probability for a single transaction"""
        X = pd.DataFrame([features_dict])[self.feature_cols]
        proba = self.model.predict_proba(X)[0, 1]
        confidence = abs(proba - 0.5) * 2
        
        return {
            'malware_subscore': float(proba),
            'confidence': float(confidence),
            'indicators': self._get_indicators(features_dict, proba)
        }
    
    def _get_indicators(self, features, score):
        """Get human-readable indicators"""
        indicators = []
        
        if score > 0.7:
            indicators.append("High device compromise risk")
        if features.get('app_modified', 0) == 1:
            indicators.append("UPI app has been modified")
        if features.get('root_jailbreak', 0) == 1:
            indicators.append("Device is rooted/jailbroken")
        if features.get('suspicious_permissions', 0) > 5:
            indicators.append(f"Excessive permissions ({features['suspicious_permissions']})")
        if features.get('has_overlay_attack', 0) == 1:
            indicators.append("Overlay attack detected")
        if features.get('clipboard_hijack', 0) == 1:
            indicators.append("Clipboard hijacking detected")
        if features.get('app_from_unknown_source', 0) == 1:
            indicators.append("App from untrusted source")
        
        return indicators
    
    def save(self, path='malware_detector.pkl'):
        """Save trained model"""
        joblib.dump(self.model, path)
        
        # Convert numpy types to Python types for JSON serialization
        feature_importance_clean = {
            k: float(v) for k, v in self.feature_importance.items()
        }
        
        metadata = {
            'feature_cols': self.feature_cols,
            'feature_importance': feature_importance_clean
        }
        with open(path.replace('.pkl', '_metadata.json'), 'w') as f:
            json.dump(metadata, f, indent=2)
        
        print(f"Model saved to {path}")
    
    def load(self, path='malware_detector.pkl'):
        """Load trained model"""
        self.model = joblib.load(path)
        
        with open(path.replace('.pkl', '_metadata.json'), 'r') as f:
            metadata = json.load(f)
            self.feature_importance = metadata['feature_importance']
        
        print(f"Model loaded from {path}")

if __name__ == "__main__":
    df = pd.read_csv('../upi_transactions_engineered.csv')
    
    detector = MalwareDetector()
    detector.train(df)
    detector.save('malware_detector.pkl')
    
    print("\nâœ“ Malware detector trained and saved successfully!")
